"""
Real Exploitation Integration
Connects HTTP engine, browser automation, and evidence collection to existing plugins
"""

import asyncio
from typing import Dict, Any, List, Optional
from .http_engine import HTTPEngine, patch_plugin_with_http
from .browser_engine import BrowserEngine
import logging

logger = logging.getLogger(__name__)

class RealExploitationIntegration:
    """Integrate real exploitation into existing framework"""
    
    def __init__(self, orchestrator):
        self.orchestrator = orchestrator
        self.http_engine = HTTPEngine()
        self.browser_engine = BrowserEngine()
        
        # Patch existing plugins
        self._patch_plugins()
    
    def _patch_plugins(self):
        """Patch all loaded plugins with real HTTP"""
        
        # Get plugin registry
        if hasattr(self.orchestrator, 'plugin_registry'):
            registry = self.orchestrator.plugin_registry
            
            # Patch each plugin class
            for plugin_name in registry._plugins:
                plugin_class = registry._plugins[plugin_name]
                
                # Add HTTP engine to plugin
                original_init = plugin_class.__init__
                
                def new_init(self, *args, **kwargs):
                    original_init(self, *args, **kwargs)
                    self.http_engine = HTTPEngine()
                    self.browser_engine = BrowserEngine() if 'XSS' in self.__class__.__name__ else None
                
                plugin_class.__init__ = new_init
                
                # Wrap run method
                patch_plugin_with_http(plugin_class)
                
                logger.info(f"Patched {plugin_name} with real HTTP capabilities")
    
    async def execute_with_evidence(self, target: str, plugin_name: str, **kwargs) -> Dict[str, Any]:
        """Execute plugin with real exploitation and evidence collection"""
        
        # Add real HTTP flag
        kwargs['use_real_http'] = True
        
        # Execute plugin
        result = self.orchestrator.execute_plugin(plugin_name, {'target': target, **kwargs})
        
        # Collect evidence
        evidence = {
            'plugin': plugin_name,
            'http_evidence': self.http_engine.get_all_evidence(),
            'browser_evidence': None
        }
        
        # For XSS, use browser
        if 'XSS' in plugin_name.upper():
            browser_result = self.browser_engine.execute_js_payload(
                target,
                kwargs.get('payload', '<script>alert(1)</script>')
            )
            evidence['browser_evidence'] = browser_result.get('evidence')
        
        # Generate PoC
        poc = self._generate_poc(target, plugin_name, evidence)
        
        return {
            'result': result,
            'evidence': evidence,
            'poc': poc
        }
    
    def _generate_poc(self, target: str, plugin_name: str, evidence: Dict) -> str:
        """Generate reproducible PoC from evidence"""
        
        poc_template = f"""
# Proof of Concept - {plugin_name}
# Target: {target}
# Generated: {datetime.now().isoformat()}

import requests

def exploit():
    target = "{target}"
"""
        
        # Add requests from evidence
        for http_ev in evidence.get('http_evidence', []):
            if http_ev.get('analysis', {}).get('vulnerable'):
                req = http_ev['request']
                poc_template += f"""
    # Exploitation request
    payload = "{req['payload']}"
    response = requests.{req['method'].lower()}(
        "{req['url']}",
        {"data={'" + req['param'] + "': payload}" if req['param'] else "data=payload"}
    )
    
    # Check for vulnerability indicators
    if response.status_code == {http_ev['response']['status_code']}:
        print("[+] Vulnerability confirmed!")
        print(f"Indicators: {http_ev['analysis']['indicators']}")
"""
        
        poc_template += """
if __name__ == "__main__":
    exploit()
"""
        
        return poc_template


# Monkey-patch orchestrator's execute method
def patch_orchestrator_execute(orchestrator):
    """Patch orchestrator to use real exploitation"""
    
    original_execute = orchestrator.execute
    integration = RealExploitationIntegration(orchestrator)
    
    def new_execute(target: str, llm_step_budget: int = 5) -> Dict[str, Any]:
        # Run original execute
        result = original_execute(target, llm_step_budget)
        
        # Add real exploitation evidence
        result['real_evidence'] = integration.http_engine.get_all_evidence()
        result['screenshots'] = integration.browser_engine.screenshots
        
        # Clean up browser
        integration.browser_engine.cleanup()
        
        return result
    
    orchestrator.execute = new_execute
    orchestrator.real_integration = integration
    
    logger.info("Orchestrator patched with real exploitation capabilities")
